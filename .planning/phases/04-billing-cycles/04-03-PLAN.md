---
phase: 04-billing-cycles
plan: 03
type: execute
wave: 3
depends_on: ["04-02"]
files_modified:
  - apps/finance/finance/Models/BillingCycle.swift
  - apps/finance/finance/Views/BillingCycles/BillingCycleView.swift
  - apps/finance/finance/Views/BillingCycles/BillingCycleSummaryView.swift
  - apps/finance/finance/Views/HomeView.swift
autonomous: true

must_haves:
  truths:
    - "User can view spending for current billing cycle"
    - "User can switch between single-card and combined view"
    - "User can navigate to previous/next billing periods"
    - "Combined view shows each card in its own cycle period"
    - "Calendar month view available (1st to end of month)"
    - "Days remaining indicator shows for current period"
  artifacts:
    - path: "apps/finance/finance/Models/BillingCycle.swift"
      provides: "BillingCycle struct with date calculation logic"
      contains: "BillingCycle"
    - path: "apps/finance/finance/Views/BillingCycles/BillingCycleView.swift"
      provides: "Main billing cycle view with period navigation"
      contains: "BillingCycleView"
    - path: "apps/finance/finance/Views/BillingCycles/BillingCycleSummaryView.swift"
      provides: "Summary view for single card or combined"
      contains: "BillingCycleSummaryView"
  key_links:
    - from: "apps/finance/finance/Views/BillingCycles/BillingCycleView.swift"
      to: "TransactionService.fetchTransactions"
      via: "date filter with billing cycle dates"
      pattern: "fetchTransactions.*startDate.*endDate"
---

<objective>
Create billing cycle spending view with period navigation

Purpose: Enable users to view spending within billing periods - both for individual cards and combined across all cards. Users can navigate between periods to analyze historical spending.

Output: BillingCycle model for date calculations, BillingCycleView with card/combined toggle and prev/next navigation, spending summary with category breakdown and transaction list.
</objective>

<execution_context>
@/Users/seanyasno/.claude/get-shit-done/workflows/execute-plan.md
@/Users/seanyasno/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/04-billing-cycles/04-CONTEXT.md
@.planning/phases/04-billing-cycles/04-02-SUMMARY.md

# Existing iOS views and services
@apps/finance/finance/Models/CreditCard.swift
@apps/finance/finance/Services/TransactionService.swift
@apps/finance/finance/Views/Categories/CategorySpendingView.swift
@apps/finance/finance/Views/HomeView.swift
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create BillingCycle model with date calculation logic</name>
  <files>apps/finance/finance/Models/BillingCycle.swift</files>
  <action>
Create BillingCycle.swift with logic to calculate billing period dates:

```swift
//
//  BillingCycle.swift
//  finance
//

import Foundation

/// Represents a billing cycle period with start and end dates
struct BillingCycle: Identifiable, Equatable {
    let startDate: Date
    let endDate: Date
    let card: CreditCard?  // nil for calendar month or combined view

    var id: String {
        let formatter = ISO8601DateFormatter()
        let cardId = card?.id ?? "all"
        return "\(cardId)-\(formatter.string(from: startDate))"
    }

    /// Display string for the period (e.g., "Jan 15 - Feb 14, 2026")
    var displayPeriod: String {
        let formatter = DateFormatter()
        formatter.dateFormat = "MMM d"

        let endFormatter = DateFormatter()
        endFormatter.dateFormat = "MMM d, yyyy"

        return "\(formatter.string(from: startDate)) - \(endFormatter.string(from: endDate))"
    }

    /// Days remaining in the cycle (0 if period has ended)
    var daysRemaining: Int {
        let calendar = Calendar.current
        let today = calendar.startOfDay(for: Date())
        let end = calendar.startOfDay(for: endDate)

        if today > end {
            return 0
        }

        let components = calendar.dateComponents([.day], from: today, to: end)
        return max(0, (components.day ?? 0) + 1)  // +1 to include end date
    }

    /// Whether this is the current (in-progress) cycle
    var isCurrent: Bool {
        let today = Date()
        return today >= startDate && today <= endDate
    }

    // MARK: - Static Factory Methods

    /// Creates a billing cycle for a specific card and offset (0 = current, -1 = previous, etc.)
    static func forCard(_ card: CreditCard, offset: Int = 0) -> BillingCycle {
        let billingDay = card.effectiveBillingCycleDay
        return calculateCycle(billingDay: billingDay, offset: offset, card: card)
    }

    /// Creates a calendar month cycle (1st to end of month)
    static func calendarMonth(offset: Int = 0) -> BillingCycle {
        return calculateCycle(billingDay: 1, offset: offset, card: nil)
    }

    /// Calculate the billing cycle dates for a given billing day and offset
    private static func calculateCycle(billingDay: Int, offset: Int, card: CreditCard?) -> BillingCycle {
        let calendar = Calendar.current
        let today = Date()

        // Get current month/year
        var components = calendar.dateComponents([.year, .month, .day], from: today)
        let currentDay = components.day ?? 1

        // Determine which cycle we're in
        // If today is before billing day, we're in the previous month's cycle
        var monthOffset = offset
        if currentDay < billingDay {
            monthOffset -= 1
        }

        // Calculate start date
        components.day = min(billingDay, daysInMonth(year: components.year!, month: components.month!))
        if let adjustedDate = calendar.date(from: components),
           let startDate = calendar.date(byAdding: .month, value: monthOffset, to: adjustedDate) {

            // End date is one day before next cycle starts
            if let nextCycleStart = calendar.date(byAdding: .month, value: 1, to: startDate),
               let endDate = calendar.date(byAdding: .day, value: -1, to: nextCycleStart) {

                return BillingCycle(startDate: startDate, endDate: endDate, card: card)
            }
        }

        // Fallback: shouldn't happen, but return current month
        let fallbackStart = calendar.date(from: DateComponents(year: components.year, month: components.month, day: 1))!
        let fallbackEnd = calendar.date(byAdding: DateComponents(month: 1, day: -1), to: fallbackStart)!
        return BillingCycle(startDate: fallbackStart, endDate: fallbackEnd, card: card)
    }

    /// Get number of days in a specific month
    private static func daysInMonth(year: Int, month: Int) -> Int {
        let calendar = Calendar.current
        let components = DateComponents(year: year, month: month)
        if let date = calendar.date(from: components),
           let range = calendar.range(of: .day, in: .month, for: date) {
            return range.count
        }
        return 30  // Fallback
    }
}

// MARK: - View Mode

enum BillingCycleViewMode: String, CaseIterable, Identifiable {
    case combined = "All Cards"
    case singleCard = "Single Card"
    case calendarMonth = "Calendar Month"

    var id: String { rawValue }
}
```
  </action>
  <verify>
Build iOS project in Xcode - BillingCycle.swift should compile without errors.
  </verify>
  <done>
BillingCycle model with date calculations for card-specific and calendar cycles.
View mode enum for switching between combined/single/calendar views.
  </done>
</task>

<task type="auto">
  <name>Task 2: Create BillingCycleView with period navigation and spending display</name>
  <files>
apps/finance/finance/Views/BillingCycles/BillingCycleView.swift
apps/finance/finance/Views/BillingCycles/BillingCycleSummaryView.swift
apps/finance/finance/Views/HomeView.swift
  </files>
  <action>
1. Create BillingCycles folder, then create BillingCycleView.swift:

```swift
//
//  BillingCycleView.swift
//  finance
//

import SwiftUI

struct BillingCycleView: View {
    @StateObject private var transactionService = TransactionService()
    @StateObject private var categoryService = CategoryService()

    @State private var viewMode: BillingCycleViewMode = .combined
    @State private var selectedCard: CreditCard?
    @State private var periodOffset: Int = 0  // 0 = current, -1 = previous, etc.

    var body: some View {
        VStack(spacing: 0) {
            // View mode picker
            Picker("View Mode", selection: $viewMode) {
                ForEach(BillingCycleViewMode.allCases) { mode in
                    Text(mode.rawValue).tag(mode)
                }
            }
            .pickerStyle(.segmented)
            .padding()

            // Card selector (only for single card mode)
            if viewMode == .singleCard {
                if transactionService.creditCards.isEmpty {
                    Text("No cards available")
                        .foregroundColor(.secondary)
                        .padding()
                } else {
                    Picker("Select Card", selection: $selectedCard) {
                        ForEach(transactionService.creditCards) { card in
                            Text(card.displayName).tag(card as CreditCard?)
                        }
                    }
                    .pickerStyle(.menu)
                    .padding(.horizontal)
                }
            }

            // Period navigation
            HStack {
                Button {
                    periodOffset -= 1
                    Task { await loadTransactions() }
                } label: {
                    Image(systemName: "chevron.left")
                        .font(.title2)
                }

                Spacer()

                VStack {
                    Text(currentPeriodDisplay)
                        .font(.headline)
                    if let daysRemaining = currentCycle?.daysRemaining, currentCycle?.isCurrent == true {
                        Text("\(daysRemaining) days remaining")
                            .font(.caption)
                            .foregroundColor(.secondary)
                    }
                }

                Spacer()

                Button {
                    periodOffset += 1
                    Task { await loadTransactions() }
                } label: {
                    Image(systemName: "chevron.right")
                }
                .disabled(periodOffset >= 0)  // Can't go into future
            }
            .padding()
            .background(Color(.systemGray6))

            // Spending content
            if transactionService.isLoading {
                Spacer()
                ProgressView("Loading...")
                Spacer()
            } else {
                BillingCycleSummaryView(
                    transactions: filteredTransactions,
                    categories: categoryService.categories,
                    transactionService: transactionService
                )
            }
        }
        .navigationTitle("Billing Cycles")
        .onChange(of: viewMode) { _, _ in
            periodOffset = 0  // Reset to current when changing view mode
            Task { await loadTransactions() }
        }
        .onChange(of: selectedCard) { _, _ in
            Task { await loadTransactions() }
        }
        .task {
            await loadInitialData()
        }
    }

    // MARK: - Computed Properties

    private var currentCycle: BillingCycle? {
        switch viewMode {
        case .combined:
            // For combined, use the first card's cycle or calendar month
            if let firstCard = transactionService.creditCards.first {
                return BillingCycle.forCard(firstCard, offset: periodOffset)
            }
            return BillingCycle.calendarMonth(offset: periodOffset)
        case .singleCard:
            guard let card = selectedCard else { return nil }
            return BillingCycle.forCard(card, offset: periodOffset)
        case .calendarMonth:
            return BillingCycle.calendarMonth(offset: periodOffset)
        }
    }

    private var currentPeriodDisplay: String {
        currentCycle?.displayPeriod ?? "Select a period"
    }

    private var filteredTransactions: [Transaction] {
        guard let cycle = currentCycle else { return [] }

        return transactionService.transactions.filter { transaction in
            guard let date = transaction.date else { return false }

            // Date must be within cycle
            let inDateRange = date >= cycle.startDate && date <= cycle.endDate

            // For single card mode, also filter by card
            if viewMode == .singleCard, let selectedCard = selectedCard {
                return inDateRange && transaction.creditCardId == selectedCard.id
            }

            return inDateRange
        }
    }

    // MARK: - Data Loading

    private func loadInitialData() async {
        await withTaskGroup(of: Void.self) { group in
            group.addTask { await transactionService.fetchCreditCards() }
            group.addTask { await categoryService.fetchCategories() }
        }

        // Set default selected card
        if selectedCard == nil {
            selectedCard = transactionService.creditCards.first
        }

        await loadTransactions()
    }

    private func loadTransactions() async {
        // Load all transactions within reasonable date range
        // The UI will filter based on billing cycle
        guard let cycle = currentCycle else { return }

        await transactionService.fetchTransactions(
            startDate: cycle.startDate,
            endDate: cycle.endDate,
            creditCardId: viewMode == .singleCard ? selectedCard?.id : nil
        )
    }
}

#Preview {
    NavigationStack {
        BillingCycleView()
    }
}
```

2. Create BillingCycleSummaryView.swift:

```swift
//
//  BillingCycleSummaryView.swift
//  finance
//

import SwiftUI

struct BillingCycleSummaryView: View {
    let transactions: [Transaction]
    let categories: [Category]
    let transactionService: TransactionService

    var body: some View {
        if transactions.isEmpty {
            ContentUnavailableView(
                "No Transactions",
                systemImage: "creditcard.trianglebadge.exclamationmark",
                description: Text("No transactions in this billing period")
            )
        } else {
            List {
                // Total spending header
                Section {
                    HStack {
                        Text("Total Spending")
                            .font(.headline)
                        Spacer()
                        Text(formattedTotal)
                            .font(.title2)
                            .fontWeight(.bold)
                    }
                    .padding(.vertical, 8)
                }

                // Category breakdown
                Section("By Category") {
                    ForEach(groupedByCategory) { group in
                        DisclosureGroup {
                            ForEach(group.transactions) { transaction in
                                NavigationLink {
                                    TransactionDetailView(
                                        transaction: transaction,
                                        transactionService: transactionService
                                    )
                                } label: {
                                    TransactionRowView(transaction: transaction)
                                }
                            }
                        } label: {
                            HStack {
                                if let category = group.category {
                                    Image(systemName: category.displayIcon)
                                        .foregroundColor(category.displayColor)
                                        .frame(width: 24)
                                    Text(category.name)
                                } else {
                                    Image(systemName: "questionmark.circle")
                                        .foregroundColor(.secondary)
                                        .frame(width: 24)
                                    Text("Uncategorized")
                                        .foregroundColor(.secondary)
                                }

                                Spacer()

                                VStack(alignment: .trailing) {
                                    Text(formatAmount(group.total))
                                        .fontWeight(.medium)
                                    Text("\(group.percentage)%")
                                        .font(.caption)
                                        .foregroundColor(.secondary)
                                }
                            }
                        }
                    }
                }
            }
        }
    }

    // MARK: - Computed Properties

    private var totalSpending: Double {
        transactions.reduce(0) { $0 + $1.chargedAmount }
    }

    private var formattedTotal: String {
        formatAmount(totalSpending)
    }

    private struct CategoryGroup: Identifiable {
        let category: Category?
        let transactions: [Transaction]
        let percentage: Int

        var id: String { category?.id ?? "uncategorized" }
        var total: Double { transactions.reduce(0) { $0 + $1.chargedAmount } }
    }

    private var groupedByCategory: [CategoryGroup] {
        let grouped = Dictionary(grouping: transactions) { $0.categoryId }
        let total = totalSpending

        var result: [CategoryGroup] = []

        for (categoryId, transactions) in grouped {
            let category = categoryId.flatMap { id in
                categories.first { $0.id == id }
            }
            let groupTotal = transactions.reduce(0) { $0 + $1.chargedAmount }
            let percentage = total > 0 ? Int((groupTotal / total) * 100) : 0

            result.append(CategoryGroup(
                category: category,
                transactions: transactions,
                percentage: percentage
            ))
        }

        // Sort by total (highest first), uncategorized at end
        result.sort { first, second in
            if first.category == nil { return false }
            if second.category == nil { return true }
            return first.total > second.total
        }

        return result
    }

    private func formatAmount(_ amount: Double) -> String {
        String(format: "â‚ª%.2f", amount)
    }
}

#Preview {
    NavigationStack {
        BillingCycleSummaryView(
            transactions: [],
            categories: [],
            transactionService: TransactionService()
        )
    }
}
```

3. Update HomeView.swift to replace the existing "Spending" tab with "Cycles" tab:

Change the second tab from CategorySpendingView to BillingCycleView:

```swift
NavigationStack {
    BillingCycleView()
        .toolbar {
            ToolbarItem(placement: .navigationBarTrailing) {
                Button("Logout") {
                    Task {
                        await authManager.logout()
                    }
                }
            }
        }
}
.tabItem {
    Label("Cycles", systemImage: "calendar")
}
```

Keep the CategorySpendingView accessible - it could be accessed from within BillingCycleView or kept as a separate feature. For now, the Billing Cycles view includes category breakdown, so it replaces the separate "Spending" tab.

The final tab order should be:
1. Transactions (list.bullet)
2. Cycles (calendar) - new billing cycle view
3. Categories (tag) - category management
4. Cards (creditcard) - card settings
  </action>
  <verify>
1. Build iOS project in Xcode - should compile without errors
2. Run app - should see 4 tabs with "Cycles" as the second tab
3. Cycles view should show:
   - Segmented picker for All Cards / Single Card / Calendar Month
   - Period navigation with left/right chevrons
   - Days remaining indicator for current period
   - Total spending and category breakdown for the period
4. Navigate to previous periods using chevron.left
5. Single Card mode should show card picker and filter transactions
  </verify>
  <done>
BillingCycleView with mode picker (combined/single/calendar), period navigation.
BillingCycleSummaryView shows total, category breakdown with percentages.
Days remaining indicator for current period.
Navigation between periods works (prev/next).
  </done>
</task>

</tasks>

<verification>
1. iOS Build: Project compiles without errors
2. BillingCycle Model: Date calculations work correctly for different billing days
3. View Modes: Can switch between All Cards, Single Card, and Calendar Month
4. Period Navigation: Previous button navigates to earlier periods, next button disabled when at current
5. Days Remaining: Shows correct count for current period, hidden for past periods
6. Spending Display: Total spending and category breakdown with percentages
7. Transaction List: Transactions grouped by category, expandable via DisclosureGroup
</verification>

<success_criteria>
- User can view spending for current billing cycle (BILL-02)
- User can view combined spending across all cards (BILL-03)
- User can view spending by calendar month (BILL-04)
- User can navigate between billing periods (BILL-05)
- Days remaining indicator visible for current period
- Category breakdown with percentages shown
</success_criteria>

<output>
After completion, create `.planning/phases/04-billing-cycles/04-03-SUMMARY.md`
</output>
