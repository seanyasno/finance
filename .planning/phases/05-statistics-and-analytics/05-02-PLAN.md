---
phase: 05-statistics-and-analytics
plan: 02
type: execute
wave: 2
depends_on: ["05-01"]
files_modified:
  - apps/api/src/statistics/statistics.module.ts
  - apps/api/src/statistics/statistics.controller.ts
  - apps/api/src/statistics/statistics.service.ts
  - apps/api/src/statistics/dto/spending-summary.dto.ts
  - apps/api/src/statistics/dto/index.ts
  - apps/api/src/app.module.ts
autonomous: true

must_haves:
  truths:
    - "GET /statistics/spending-summary returns 5-month spending data"
    - "Response includes monthly totals with category breakdowns"
    - "Response includes month-over-month comparison data"
    - "Response includes trend indicators"
  artifacts:
    - path: "apps/api/src/statistics/statistics.module.ts"
      provides: "Statistics NestJS module"
      exports: ["StatisticsModule"]
    - path: "apps/api/src/statistics/statistics.controller.ts"
      provides: "Statistics API controller"
      exports: ["StatisticsController"]
    - path: "apps/api/src/statistics/statistics.service.ts"
      provides: "Statistics business logic"
      exports: ["StatisticsService"]
    - path: "apps/api/src/statistics/dto/spending-summary.dto.ts"
      provides: "Spending summary DTOs for OpenAPI"
      contains: "SpendingSummaryDto"
  key_links:
    - from: "apps/api/src/statistics/statistics.controller.ts"
      to: "apps/api/src/statistics/statistics.service.ts"
      via: "dependency injection"
      pattern: "constructor.*StatisticsService"
    - from: "apps/api/src/app.module.ts"
      to: "apps/api/src/statistics/statistics.module.ts"
      via: "module import"
      pattern: "StatisticsModule"
---

<objective>
Create NestJS Statistics module with spending summary API endpoint.

Purpose: Provide aggregated spending data optimized for chart display - 5-month history with category breakdowns, comparisons, and trend indicators.

Output: GET /statistics/spending-summary endpoint returning all data needed for iOS analytics UI.
</objective>

<execution_context>
@/Users/seanyasno/.claude/get-shit-done/workflows/execute-plan.md
@/Users/seanyasno/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/05-statistics-and-analytics/05-01-SUMMARY.md
@apps/api/src/transactions/transactions.service.ts
@apps/api/src/transactions/dto/transaction.dto.ts
@apps/api/src/categories/dto/category.dto.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create Statistics DTOs with OpenAPI decorators</name>
  <files>
    apps/api/src/statistics/dto/spending-summary.dto.ts
    apps/api/src/statistics/dto/index.ts
  </files>
  <action>
1. Create `apps/api/src/statistics/dto/spending-summary.dto.ts`:

```typescript
import { z } from 'zod';
import { createZodDto } from 'nestjs-zod';

// Category spending within a month
const CategorySpendingSchema = z.object({
  categoryId: z.string().nullable(),
  categoryName: z.string(),
  amount: z.number(),
  percentage: z.number(),
  transactionCount: z.number(),
});

// Single month data
const MonthlySpendingSchema = z.object({
  month: z.string(),           // "2026-01" format
  monthLabel: z.string(),      // "January 2026" display format
  total: z.number(),
  categoryBreakdown: z.array(CategorySpendingSchema),
});

// Trend direction enum
const TrendDirectionSchema = z.enum(['up', 'down', 'stable']);

// Category trend
const CategoryTrendSchema = z.object({
  categoryId: z.string().nullable(),
  categoryName: z.string(),
  trend: TrendDirectionSchema,
  averageMonthly: z.number(),
  currentMonth: z.number(),
  changePercent: z.number(),
});

// Month-over-month comparison
const MonthComparisonSchema = z.object({
  currentMonth: z.string(),
  previousMonth: z.string().nullable(),
  currentTotal: z.number(),
  previousTotal: z.number().nullable(),
  changeAmount: z.number().nullable(),
  changePercent: z.number().nullable(),
  trend: TrendDirectionSchema,
  categoryComparisons: z.array(z.object({
    categoryId: z.string().nullable(),
    categoryName: z.string(),
    currentAmount: z.number(),
    previousAmount: z.number().nullable(),
    changeAmount: z.number().nullable(),
    changePercent: z.number().nullable(),
    trend: TrendDirectionSchema,
  })),
});

// Full spending summary response
const SpendingSummarySchema = z.object({
  months: z.array(MonthlySpendingSchema),
  comparison: MonthComparisonSchema,
  trends: z.object({
    overall: TrendDirectionSchema,
    overallAverageMonthly: z.number(),
    categoryTrends: z.array(CategoryTrendSchema),
  }),
});

export class CategorySpendingDto extends createZodDto(CategorySpendingSchema) {}
export class MonthlySpendingDto extends createZodDto(MonthlySpendingSchema) {}
export class MonthComparisonDto extends createZodDto(MonthComparisonSchema) {}
export class SpendingSummaryDto extends createZodDto(SpendingSummarySchema) {}
```

2. Create `apps/api/src/statistics/dto/index.ts`:
```typescript
export * from './spending-summary.dto';
```
  </action>
  <verify>
    - `cat apps/api/src/statistics/dto/spending-summary.dto.ts` shows complete DTOs
    - `cat apps/api/src/statistics/dto/index.ts` shows exports
  </verify>
  <done>
    Statistics DTOs defined with Zod schemas and createZodDto for OpenAPI generation
  </done>
</task>

<task type="auto">
  <name>Task 2: Create Statistics module, service, and controller</name>
  <files>
    apps/api/src/statistics/statistics.module.ts
    apps/api/src/statistics/statistics.service.ts
    apps/api/src/statistics/statistics.controller.ts
    apps/api/src/app.module.ts
  </files>
  <action>
1. Create `apps/api/src/statistics/statistics.service.ts`:

```typescript
import { Injectable } from '@nestjs/common';
import { PrismaService } from '@finance/database';
import { SpendingSummaryDto, CategorySpendingDto, MonthlySpendingDto } from './dto';

@Injectable()
export class StatisticsService {
  constructor(private prisma: PrismaService) {}

  async getSpendingSummary(userId: string): Promise<SpendingSummaryDto> {
    // Get last 5 months of data
    const now = new Date();
    const fiveMonthsAgo = new Date(now.getFullYear(), now.getMonth() - 4, 1);

    // Fetch all transactions in range
    const transactions = await this.prisma.transaction.findMany({
      where: {
        userId,
        timestamp: { gte: fiveMonthsAgo },
      },
      include: { category: true },
      orderBy: { timestamp: 'desc' },
    });

    // Group transactions by month
    const monthlyData = this.groupByMonth(transactions);

    // Build monthly spending array (last 5 months, chronological)
    const months: MonthlySpendingDto[] = [];
    for (let i = 4; i >= 0; i--) {
      const monthDate = new Date(now.getFullYear(), now.getMonth() - i, 1);
      const monthKey = this.formatMonthKey(monthDate);
      const monthLabel = this.formatMonthLabel(monthDate);
      const monthTransactions = monthlyData.get(monthKey) || [];

      months.push({
        month: monthKey,
        monthLabel,
        total: this.sumAmount(monthTransactions),
        categoryBreakdown: this.getCategoryBreakdown(monthTransactions),
      });
    }

    // Calculate comparison (current vs previous month)
    const currentMonth = months[months.length - 1];
    const previousMonth = months[months.length - 2];

    const comparison = this.calculateComparison(currentMonth, previousMonth);

    // Calculate trends across all 5 months
    const trends = this.calculateTrends(months);

    return { months, comparison, trends };
  }

  private groupByMonth(transactions: any[]): Map<string, any[]> {
    const grouped = new Map<string, any[]>();
    for (const tx of transactions) {
      const monthKey = this.formatMonthKey(new Date(tx.timestamp));
      if (!grouped.has(monthKey)) {
        grouped.set(monthKey, []);
      }
      grouped.get(monthKey)!.push(tx);
    }
    return grouped;
  }

  private formatMonthKey(date: Date): string {
    return `${date.getFullYear()}-${String(date.getMonth() + 1).padStart(2, '0')}`;
  }

  private formatMonthLabel(date: Date): string {
    return date.toLocaleDateString('en-US', { month: 'long', year: 'numeric' });
  }

  private sumAmount(transactions: any[]): number {
    return transactions.reduce((sum, tx) => sum + (tx.chargedAmount || 0), 0);
  }

  private getCategoryBreakdown(transactions: any[]): CategorySpendingDto[] {
    const byCategory = new Map<string | null, { name: string; amount: number; count: number }>();
    const total = this.sumAmount(transactions);

    for (const tx of transactions) {
      const categoryId = tx.categoryId;
      const categoryName = tx.category?.name || 'Uncategorized';

      if (!byCategory.has(categoryId)) {
        byCategory.set(categoryId, { name: categoryName, amount: 0, count: 0 });
      }
      const cat = byCategory.get(categoryId)!;
      cat.amount += tx.chargedAmount || 0;
      cat.count += 1;
    }

    return Array.from(byCategory.entries())
      .map(([categoryId, data]) => ({
        categoryId,
        categoryName: data.name,
        amount: data.amount,
        percentage: total > 0 ? Math.round((data.amount / total) * 100) : 0,
        transactionCount: data.count,
      }))
      .sort((a, b) => b.amount - a.amount);
  }

  private calculateComparison(current: MonthlySpendingDto, previous: MonthlySpendingDto) {
    const changeAmount = previous.total > 0 ? current.total - previous.total : null;
    const changePercent = previous.total > 0
      ? Math.round(((current.total - previous.total) / previous.total) * 100)
      : null;

    const trend = this.determineTrend(changePercent);

    // Build category comparisons
    const allCategories = new Set([
      ...current.categoryBreakdown.map(c => c.categoryId),
      ...previous.categoryBreakdown.map(c => c.categoryId),
    ]);

    const categoryComparisons = Array.from(allCategories).map(categoryId => {
      const currentCat = current.categoryBreakdown.find(c => c.categoryId === categoryId);
      const previousCat = previous.categoryBreakdown.find(c => c.categoryId === categoryId);

      const currentAmount = currentCat?.amount || 0;
      const previousAmount = previousCat?.amount || null;
      const catChangeAmount = previousAmount !== null ? currentAmount - previousAmount : null;
      const catChangePercent = previousAmount && previousAmount > 0
        ? Math.round(((currentAmount - previousAmount) / previousAmount) * 100)
        : null;

      return {
        categoryId,
        categoryName: currentCat?.categoryName || previousCat?.categoryName || 'Unknown',
        currentAmount,
        previousAmount,
        changeAmount: catChangeAmount,
        changePercent: catChangePercent,
        trend: this.determineTrend(catChangePercent),
      };
    }).sort((a, b) => b.currentAmount - a.currentAmount);

    return {
      currentMonth: current.month,
      previousMonth: previous.month,
      currentTotal: current.total,
      previousTotal: previous.total,
      changeAmount,
      changePercent,
      trend,
      categoryComparisons,
    };
  }

  private calculateTrends(months: MonthlySpendingDto[]) {
    const totals = months.map(m => m.total);
    const average = totals.reduce((a, b) => a + b, 0) / totals.length;
    const currentMonth = totals[totals.length - 1];

    // Simple trend: compare current to average
    const overallChangePercent = average > 0
      ? Math.round(((currentMonth - average) / average) * 100)
      : 0;
    const overall = this.determineTrend(overallChangePercent);

    // Category trends
    const allCategories = new Map<string | null, { name: string; monthlyAmounts: number[] }>();

    for (let i = 0; i < months.length; i++) {
      for (const cat of months[i].categoryBreakdown) {
        if (!allCategories.has(cat.categoryId)) {
          allCategories.set(cat.categoryId, {
            name: cat.categoryName,
            monthlyAmounts: new Array(months.length).fill(0)
          });
        }
        allCategories.get(cat.categoryId)!.monthlyAmounts[i] = cat.amount;
      }
    }

    const categoryTrends = Array.from(allCategories.entries()).map(([categoryId, data]) => {
      const catAverage = data.monthlyAmounts.reduce((a, b) => a + b, 0) / data.monthlyAmounts.length;
      const catCurrent = data.monthlyAmounts[data.monthlyAmounts.length - 1];
      const catChangePercent = catAverage > 0
        ? Math.round(((catCurrent - catAverage) / catAverage) * 100)
        : 0;

      return {
        categoryId,
        categoryName: data.name,
        trend: this.determineTrend(catChangePercent),
        averageMonthly: Math.round(catAverage * 100) / 100,
        currentMonth: catCurrent,
        changePercent: catChangePercent,
      };
    }).sort((a, b) => b.currentMonth - a.currentMonth);

    return {
      overall,
      overallAverageMonthly: Math.round(average * 100) / 100,
      categoryTrends,
    };
  }

  private determineTrend(changePercent: number | null): 'up' | 'down' | 'stable' {
    if (changePercent === null) return 'stable';
    if (changePercent > 5) return 'up';
    if (changePercent < -5) return 'down';
    return 'stable';
  }
}
```

2. Create `apps/api/src/statistics/statistics.controller.ts`:

```typescript
import { Controller, Get } from '@nestjs/common';
import { ApiTags, ApiOperation, ApiOkResponse } from '@nestjs/swagger';
import { StatisticsService } from './statistics.service';
import { SpendingSummaryDto } from './dto';
import { CurrentUser, JwtAuth } from '../auth/auth.decorator';

@ApiTags('statistics')
@Controller('statistics')
export class StatisticsController {
  constructor(private readonly statisticsService: StatisticsService) {}

  @Get('spending-summary')
  @JwtAuth()
  @ApiOperation({ summary: 'Get spending summary for last 5 months' })
  @ApiOkResponse({ type: SpendingSummaryDto })
  async getSpendingSummary(@CurrentUser() user: { id: string }): Promise<SpendingSummaryDto> {
    return this.statisticsService.getSpendingSummary(user.id);
  }
}
```

3. Create `apps/api/src/statistics/statistics.module.ts`:

```typescript
import { Module } from '@nestjs/common';
import { StatisticsController } from './statistics.controller';
import { StatisticsService } from './statistics.service';
import { AuthModule } from '../auth/auth.module';

@Module({
  imports: [AuthModule],
  controllers: [StatisticsController],
  providers: [StatisticsService],
})
export class StatisticsModule {}
```

4. Update `apps/api/src/app.module.ts`:
   - Add `import { StatisticsModule } from './statistics/statistics.module';`
   - Add `StatisticsModule` to imports array
  </action>
  <verify>
    - `cd apps/api && npm run build` succeeds
    - `curl http://localhost:3100/api-json | jq '.paths["/statistics/spending-summary"]'` shows endpoint in OpenAPI
    - Test endpoint manually: `curl -b cookies.txt http://localhost:3100/statistics/spending-summary` returns data
  </verify>
  <done>
    Statistics API module complete with GET /statistics/spending-summary returning 5-month aggregated data
  </done>
</task>

</tasks>

<verification>
1. API builds: `cd apps/api && npm run build`
2. Endpoint appears in Swagger UI at http://localhost:3100/api
3. Endpoint returns expected structure with months array, comparison, and trends
4. Run `npm run generate:swift` to regenerate Swift models including new DTOs
</verification>

<success_criteria>
- GET /statistics/spending-summary returns valid SpendingSummaryDto
- Response includes 5 months of data with category breakdowns
- Comparison shows current vs previous month with changes
- Trends calculated across full 5-month period
- OpenAPI spec includes all new DTOs for Swift generation
</success_criteria>

<output>
After completion, create `.planning/phases/05-statistics-and-analytics/05-02-SUMMARY.md`
</output>
