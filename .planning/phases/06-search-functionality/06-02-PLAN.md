---
phase: 06-search-functionality
plan: 02
type: execute
wave: 2
depends_on: ["06-01"]
files_modified:
  - apps/finance/finance/Services/TransactionService.swift
  - apps/finance/finance/Views/Transactions/TransactionListView.swift
autonomous: true

must_haves:
  truths:
    - "User can type in search bar and see transactions filtered in real-time"
    - "Search appears in navigation bar using native SwiftUI .searchable() modifier"
    - "Search is debounced to avoid excessive API calls"
    - "Empty search results show clear message with the search query displayed"
    - "Pull-to-refresh works during active search without cancelling search"
    - "Clearing search instantly restores full transaction list"
  artifacts:
    - path: "apps/finance/finance/Views/Transactions/TransactionListView.swift"
      provides: "Search UI with .searchable() and debounce logic"
      contains: ".searchable"
    - path: "apps/finance/finance/Services/TransactionService.swift"
      provides: "Search parameter in API call"
      contains: "search:"
  key_links:
    - from: "apps/finance/finance/Views/Transactions/TransactionListView.swift"
      to: "apps/finance/finance/Services/TransactionService.swift"
      via: "searchText passed to fetchTransactions"
      pattern: "fetchTransactions.*search"
    - from: "apps/finance/finance/Services/TransactionService.swift"
      to: "TransactionsAPI"
      via: "search parameter in API call"
      pattern: "getTransactions.*search"
---

<objective>
Add real-time search capability to the iOS transaction list with native SwiftUI search bar.

Purpose: Enable users to quickly find transactions by typing merchant name, amount, or notes, with debounced API calls and proper state management for search + refresh interaction.
Output: TransactionListView with `.searchable()` modifier, debounced search triggering API calls, and proper empty state messaging.
</objective>

<execution_context>
@/Users/seanyasno/.claude/get-shit-done/workflows/execute-plan.md
@/Users/seanyasno/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/06-search-functionality/06-CONTEXT.md
@.planning/phases/06-search-functionality/06-01-SUMMARY.md
@apps/finance/finance/Views/Transactions/TransactionListView.swift
@apps/finance/finance/Services/TransactionService.swift
</context>

<tasks>

<task type="auto">
  <name>Task 1: Regenerate OpenAPI client with search parameter</name>
  <files>packages/api-client (generated)</files>
  <action>
Regenerate the Swift API client to include the new search parameter:

1. Ensure API server is running with updated code:
```bash
cd apps/api && npm run start:dev
```

2. Regenerate OpenAPI client:
```bash
cd apps/api && npm run codegen
```

3. Verify the generated TransactionsAPI now includes search parameter in getTransactions method.

The codegen should pick up the new search query parameter from the Swagger/OpenAPI spec automatically.
  </action>
  <verify>
Check generated code includes search parameter:
```bash
grep -r "search" apps/finance/finance/OpenAPI/APIs/TransactionsAPI.swift | head -5
```
  </verify>
  <done>TransactionsAPI.getTransactions() accepts search parameter</done>
</task>

<task type="auto">
  <name>Task 2: Add search parameter to TransactionService</name>
  <files>apps/finance/finance/Services/TransactionService.swift</files>
  <action>
Update the `fetchTransactions` method to accept and pass search parameter:

1. Add `search: String? = nil` parameter to `fetchTransactions` method signature

2. Pass search to the API call. The generated OpenAPI client should now have a search parameter.

3. Method signature becomes:
```swift
func fetchTransactions(
    startDate: Date? = nil,
    endDate: Date? = nil,
    creditCardId: String? = nil,
    search: String? = nil
) async
```

4. In the API call, pass the search parameter (likely as-is since it's already a String).

Note: Check generated TransactionsAPI.getTransactions signature for exact parameter name and position.
  </action>
  <verify>
Build the iOS project to verify no compilation errors:
```bash
cd apps/finance && xcodebuild -scheme finance -destination 'platform=iOS Simulator,name=iPhone 16 Pro' build 2>&1 | tail -20
```
  </verify>
  <done>TransactionService.fetchTransactions() accepts optional search parameter and passes it to API</done>
</task>

<task type="auto">
  <name>Task 3: Add searchable modifier and debounce to TransactionListView</name>
  <files>apps/finance/finance/Views/Transactions/TransactionListView.swift</files>
  <action>
Add search UI with proper debouncing and state management:

1. Add search state:
```swift
@State private var searchText: String = ""
@State private var debouncedSearchText: String = ""
```

2. Add `.searchable()` modifier to the view (on the Group or List):
```swift
.searchable(text: $searchText, prompt: "Search transactions")
```

3. Implement debounce using onChange + Task with sleep:
```swift
.onChange(of: searchText) { oldValue, newValue in
    // Cancel previous debounce task and start new one
    Task {
        try? await Task.sleep(nanoseconds: 300_000_000) // 300ms debounce
        // Check if searchText hasn't changed during sleep
        if searchText == newValue {
            debouncedSearchText = newValue
            await performSearch()
        }
    }
}
```

Alternative approach using a dedicated debounce pattern:
- Store debounce task reference to cancel previous
- More robust but slightly more complex

4. Create `performSearch()` method:
```swift
private func performSearch() async {
    let searchTerm = debouncedSearchText.isEmpty ? nil : debouncedSearchText
    await transactionService.fetchTransactions(
        startDate: startDate,
        endDate: endDate,
        creditCardId: selectedCardId,
        search: searchTerm
    )
}
```

5. Update `loadData()` and `applyFilters()` to include search:
```swift
private func loadData() async {
    await withTaskGroup(of: Void.self) { group in
        group.addTask {
            let searchTerm = self.debouncedSearchText.isEmpty ? nil : self.debouncedSearchText
            await self.transactionService.fetchTransactions(search: searchTerm)
        }
        group.addTask {
            await self.transactionService.fetchCreditCards()
        }
    }
}

private func applyFilters() async {
    let searchTerm = debouncedSearchText.isEmpty ? nil : debouncedSearchText
    await transactionService.fetchTransactions(
        startDate: startDate,
        endDate: endDate,
        creditCardId: selectedCardId,
        search: searchTerm
    )
}
```

6. Update `.refreshable` to preserve search during refresh:
```swift
.refreshable {
    await loadData()  // loadData now includes search
}
```

IMPORTANT: The debounce implementation must be robust:
- Use a @State property to track the debounce Task and cancel it on new input
- Or use the simpler Task.sleep approach with searchText equality check

Example robust debounce:
```swift
@State private var searchTask: Task<Void, Never>?

.onChange(of: searchText) { _, newValue in
    searchTask?.cancel()
    searchTask = Task {
        try? await Task.sleep(nanoseconds: 300_000_000)
        guard !Task.isCancelled else { return }
        debouncedSearchText = newValue
        await performSearch()
    }
}
```
  </action>
  <verify>
Build and verify:
```bash
cd apps/finance && xcodebuild -scheme finance -destination 'platform=iOS Simulator,name=iPhone 16 Pro' build 2>&1 | tail -20
```
  </verify>
  <done>
- Search bar appears in navigation bar
- Typing triggers debounced API calls (not on every keystroke)
- Search term is passed to API
- Pull-to-refresh maintains search state
  </done>
</task>

<task type="auto">
  <name>Task 4: Add empty search results messaging</name>
  <files>apps/finance/finance/Views/Transactions/TransactionListView.swift</files>
  <action>
Update the empty state to distinguish between "no transactions" and "no search results":

1. Modify the empty state condition to check if search is active:
```swift
} else if transactionService.transactions.isEmpty {
    if !debouncedSearchText.isEmpty {
        // Empty search results
        ContentUnavailableView(
            "No Results",
            systemImage: "magnifyingglass",
            description: Text("No transactions match \"\(debouncedSearchText)\"")
        )
    } else {
        // No transactions at all
        ContentUnavailableView(
            "No Transactions",
            systemImage: "creditcard",
            description: Text("Your transactions will appear here")
        )
    }
}
```

This provides clear feedback when:
- Search is active but no results found: Shows search query in message
- No search and no transactions: Shows generic empty state
  </action>
  <verify>
Build and verify:
```bash
cd apps/finance && xcodebuild -scheme finance -destination 'platform=iOS Simulator,name=iPhone 16 Pro' build 2>&1 | tail -20
```
  </verify>
  <done>
- Empty search results show "No Results" with the search query displayed
- Regular empty state shows "No Transactions" message
- Clear visual distinction between no data vs no search matches
  </done>
</task>

</tasks>

<verification>
1. iOS project builds without errors
2. Search bar appears in transaction list navigation bar
3. Typing in search triggers API call after debounce delay (not every keystroke)
4. Search filters transactions by merchant/amount/notes (as implemented in API)
5. Empty search results show search-specific message with query text
6. Pull-to-refresh works while search is active (search preserved)
7. Clearing search restores full transaction list
</verification>

<success_criteria>
- User can type in search bar and see transactions filtered in real-time
- Search is debounced (300ms) to avoid excessive API calls
- Empty search results show "No transactions match [search term]"
- Pull-to-refresh during search does not cancel search
- Clearing search text immediately restores full transaction list
</success_criteria>

<output>
After completion, create `.planning/phases/06-search-functionality/06-02-SUMMARY.md`
</output>
