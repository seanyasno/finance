---
phase: 03-categorization
plan: 04
type: execute
wave: 2
depends_on: ["03-02"]
files_modified:
  - apps/finance/finance/Models/Transaction.swift
  - apps/finance/finance/Services/TransactionService.swift
  - apps/finance/finance/Views/Transactions/TransactionDetailView.swift
  - apps/finance/finance/Views/Transactions/TransactionRowView.swift
  - apps/finance/finance/Views/Transactions/TransactionListView.swift
autonomous: true

must_haves:
  truths:
    - "User can tap a transaction to see its details"
    - "User can assign a category to a transaction"
    - "User can change a transaction's category"
    - "User can add/edit notes on a transaction"
    - "Transaction list shows category indicator when assigned"
  artifacts:
    - path: "apps/finance/finance/Views/Transactions/TransactionDetailView.swift"
      provides: "Transaction detail with category picker and notes editor"
      contains: "struct TransactionDetailView"
    - path: "apps/finance/finance/Services/TransactionService.swift"
      provides: "updateTransaction method for PATCH requests"
      contains: "updateTransaction"
  key_links:
    - from: "apps/finance/finance/Views/Transactions/TransactionDetailView.swift"
      to: "TransactionService.updateTransaction"
      via: "method call on save"
      pattern: "transactionService\\.updateTransaction"
    - from: "apps/finance/finance/Views/Transactions/TransactionListView.swift"
      to: "TransactionDetailView"
      via: "NavigationLink"
      pattern: "NavigationLink.*TransactionDetailView"
---

<objective>
Create transaction detail view with category assignment and notes editing.

Purpose: Core categorization interaction - users need to select categories and add context to transactions.
Output: TransactionDetailView with category picker, notes field, and save functionality. Transaction model updated to include category.
</objective>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/02-transaction-viewing/02-02-SUMMARY.md
@.planning/phases/02-transaction-viewing/02-03-SUMMARY.md

Existing transaction implementation:
@apps/finance/finance/Models/Transaction.swift
@apps/finance/finance/Services/TransactionService.swift
@apps/finance/finance/Views/Transactions/TransactionListView.swift
@apps/finance/finance/Views/Transactions/TransactionRowView.swift
</context>

<tasks>

<task type="auto">
  <name>Task 1: Update Transaction Model and Service</name>
  <files>
apps/finance/finance/Models/Transaction.swift
apps/finance/finance/Services/TransactionService.swift
  </files>
  <action>
**Update Transaction Model (Transaction.swift):**

Add category field to Transaction struct:
```swift
let categoryId: String?
let category: Category?
```

Update CodingKeys to include:
```swift
case categoryId
case category
```

Add computed property:
```swift
var categoryName: String? {
    category?.name
}
```

**Add UpdateTransactionRequest struct:**
```swift
struct UpdateTransactionRequest: Codable {
    let categoryId: String?
    let notes: String?

    // Allow partial updates - only include non-nil values
    func encode(to encoder: Encoder) throws {
        var container = encoder.container(keyedBy: CodingKeys.self)
        // Always encode to allow setting to null
        try container.encode(categoryId, forKey: .categoryId)
        try container.encode(notes, forKey: .notes)
    }

    enum CodingKeys: String, CodingKey {
        case categoryId
        case notes
    }
}
```

**Update TransactionService (TransactionService.swift):**

Add update method:
```swift
func updateTransaction(id: String, categoryId: String?, notes: String?) async -> Transaction? {
    let request = UpdateTransactionRequest(categoryId: categoryId, notes: notes)

    do {
        let updated: Transaction = try await apiService.patch("transactions/\(id)", body: request)
        // Update local array
        if let index = transactions.firstIndex(where: { $0.id == id }) {
            transactions[index] = updated
        }
        return updated
    } catch {
        self.error = error.localizedDescription
        return nil
    }
}
```

Note: APIService may need a `patch` method. Check if it exists, if not add it following the same pattern as `post`:
```swift
func patch<T: Decodable, U: Encodable>(_ endpoint: String, body: U) async throws -> T {
    var request = URLRequest(url: baseURL.appendingPathComponent(endpoint))
    request.httpMethod = "PATCH"
    request.setValue("application/json", forHTTPHeaderField: "Content-Type")
    request.httpBody = try JSONEncoder().encode(body)

    let (data, response) = try await session.data(for: request)
    // ... same error handling as post
}
```
  </action>
  <verify>
Xcode build succeeds.
No compiler errors in Transaction.swift or TransactionService.swift.
  </verify>
  <done>Transaction model includes category, TransactionService can update transactions via PATCH</done>
</task>

<task type="auto">
  <name>Task 2: Create Transaction Detail View</name>
  <files>
apps/finance/finance/Views/Transactions/TransactionDetailView.swift
apps/finance/finance/Views/Transactions/TransactionRowView.swift
apps/finance/finance/Views/Transactions/TransactionListView.swift
  </files>
  <action>
**TransactionDetailView (new file):**

Create a detail view for viewing and editing transaction category/notes:

```swift
struct TransactionDetailView: View {
    let transaction: Transaction
    @ObservedObject var transactionService: TransactionService
    @StateObject private var categoryService = CategoryService()

    @State private var selectedCategoryId: String?
    @State private var notes: String
    @State private var isSaving = false
    @State private var hasChanges = false

    @Environment(\.dismiss) private var dismiss

    init(transaction: Transaction, transactionService: TransactionService) {
        self.transaction = transaction
        self.transactionService = transactionService
        _selectedCategoryId = State(initialValue: transaction.categoryId)
        _notes = State(initialValue: transaction.notes ?? "")
    }

    var body: some View {
        Form {
            // Transaction Info Section (read-only)
            Section("Transaction") {
                LabeledContent("Merchant", value: transaction.merchantName)
                LabeledContent("Amount", value: transaction.formattedAmount)
                LabeledContent("Date", value: transaction.formattedDate)
                LabeledContent("Card", value: transaction.creditCard?.lastFourDigits ?? "N/A")
                LabeledContent("Status", value: transaction.status.capitalized)
            }

            // Category Section
            Section("Category") {
                Picker("Category", selection: $selectedCategoryId) {
                    Text("None").tag(nil as String?)
                    ForEach(categoryService.categories) { category in
                        Label(category.name, systemImage: category.displayIcon)
                            .tag(category.id as String?)
                    }
                }
                .onChange(of: selectedCategoryId) { hasChanges = true }
            }

            // Notes Section
            Section("Notes") {
                TextEditor(text: $notes)
                    .frame(minHeight: 100)
                    .onChange(of: notes) { hasChanges = true }
            }
        }
        .navigationTitle("Transaction Details")
        .navigationBarTitleDisplayMode(.inline)
        .toolbar {
            ToolbarItem(placement: .navigationBarTrailing) {
                Button("Save") {
                    Task { await save() }
                }
                .disabled(!hasChanges || isSaving)
            }
        }
        .task {
            await categoryService.fetchCategories()
        }
    }

    private func save() async {
        isSaving = true
        let notesToSave = notes.isEmpty ? nil : notes
        if await transactionService.updateTransaction(
            id: transaction.id,
            categoryId: selectedCategoryId,
            notes: notesToSave
        ) != nil {
            hasChanges = false
        }
        isSaving = false
    }
}
```

**Update TransactionRowView:**
Add category indicator (colored dot or icon) when transaction has a category:
```swift
// In the HStack, after merchant name or before amount:
if let category = transaction.category {
    Image(systemName: category.displayIcon)
        .foregroundColor(category.displayColor)
        .font(.caption)
}
```

**Update TransactionListView:**
Change from simple list to NavigationLink list for drill-down:
```swift
List(transactionService.transactions) { transaction in
    NavigationLink {
        TransactionDetailView(
            transaction: transaction,
            transactionService: transactionService
        )
    } label: {
        TransactionRowView(transaction: transaction)
    }
}
```

Note: TransactionListView already has NavigationStack via HomeView integration, so NavigationLink will work.
  </action>
  <verify>
Xcode build succeeds.
All previews render.
Tapping a transaction navigates to detail view.
  </verify>
  <done>Transaction detail view shows transaction info, allows category selection from picker, allows notes editing, and saves changes via PATCH API</done>
</task>

</tasks>

<verification>
1. Xcode build succeeds for finance target
2. Transaction list shows category icons for categorized transactions
3. Tapping transaction navigates to TransactionDetailView
4. Category picker shows all categories (defaults + custom)
5. Notes text editor allows input
6. Save button disabled until changes made
7. After save, transaction list reflects updated category
8. Can remove category by selecting "None"
</verification>

<success_criteria>
- Transaction model includes category field
- TransactionService.updateTransaction() calls PATCH API
- TransactionDetailView shows transaction details
- Category picker populated from CategoryService
- Notes field editable with TextEditor
- Save persists changes to API
- Transaction list updated after save
- Category indicator visible in list for categorized transactions
</success_criteria>

<output>
After completion, create `.planning/phases/03-categorization/03-04-SUMMARY.md`
</output>
