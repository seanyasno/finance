---
phase: 03-categorization
plan: 02
type: execute
wave: 1
depends_on: []
files_modified:
  - packages/database/prisma/schema.prisma
  - apps/api/src/transactions/dto/transaction.dto.ts
  - apps/api/src/transactions/transactions.service.ts
  - apps/api/src/transactions/transactions.controller.ts
autonomous: true

must_haves:
  truths:
    - "Transactions table has category_id foreign key column"
    - "User can update a transaction's category via PATCH /transactions/:id"
    - "User can update a transaction's notes via PATCH /transactions/:id"
    - "Transaction response includes category object when assigned"
  artifacts:
    - path: "packages/database/prisma/schema.prisma"
      provides: "category_id field on transactions with relation to categories"
      contains: "category_id"
    - path: "apps/api/src/transactions/transactions.controller.ts"
      provides: "PATCH endpoint for transaction updates"
      contains: "@Patch"
    - path: "apps/api/src/transactions/dto/transaction.dto.ts"
      provides: "UpdateTransactionDto and CategoryInTransactionDto"
      contains: "UpdateTransactionSchema"
  key_links:
    - from: "apps/api/src/transactions/transactions.controller.ts"
      to: "TransactionsService.update"
      via: "controller method"
      pattern: "transactionsService\\.update"
    - from: "apps/api/src/transactions/transactions.service.ts"
      to: "prisma.transactions.update"
      via: "database query"
      pattern: "prisma\\.transactions\\.update"
---

<objective>
Add category assignment capability to transactions via a PATCH endpoint.

Purpose: Enable assigning categories to transactions and updating notes - core functionality for organizing spending.
Output: PATCH /transactions/:id endpoint accepting categoryId and notes, transaction schema updated with category relation.
</objective>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/02-transaction-viewing/02-01-SUMMARY.md

Existing transaction implementation:
@apps/api/src/transactions/transactions.controller.ts
@apps/api/src/transactions/transactions.service.ts
@apps/api/src/transactions/dto/transaction.dto.ts
@packages/database/prisma/schema.prisma
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add Category Relation to Transactions Schema</name>
  <files>packages/database/prisma/schema.prisma</files>
  <action>
Update the transactions model in Prisma schema to add category relation:

Add field:
- category_id: String? @db.Uuid (optional foreign key)

Add relation:
- category: categories? @relation(fields: [category_id], references: [id])

Add the reverse relation to the categories model:
- transactions: transactions[]

Run `npx prisma db push` to apply schema changes.

Note: This task can run in parallel with 03-01 since we're just adding the column. The foreign key constraint will work once 03-01 creates the categories table.
  </action>
  <verify>
`cd packages/database && npx prisma db push` succeeds.
transactions table has category_id column.
  </verify>
  <done>transactions table has category_id foreign key pointing to categories table</done>
</task>

<task type="auto">
  <name>Task 2: Add PATCH Endpoint for Transaction Updates</name>
  <files>
apps/api/src/transactions/dto/transaction.dto.ts
apps/api/src/transactions/transactions.service.ts
apps/api/src/transactions/transactions.controller.ts
  </files>
  <action>
**DTOs (transaction.dto.ts):**

Add CategoryInTransactionSchema (similar to CreditCardInTransactionSchema):
```typescript
export const CategoryInTransactionSchema = z.object({
  id: z.string().uuid(),
  name: z.string(),
  icon: z.string().nullable(),
  color: z.string().nullable(),
  isDefault: z.boolean(),
});
```

Add UpdateTransactionSchema:
```typescript
export const UpdateTransactionSchema = z.object({
  categoryId: z.string().uuid().nullable().optional(),
  notes: z.string().nullable().optional(),
});
```

Update TransactionSchema to include category field:
```typescript
category: CategoryInTransactionSchema.nullable(),
```

**Service (transactions.service.ts):**

Add `update(userId: string, transactionId: string, data: UpdateTransactionDto)` method:
- First verify the transaction belongs to the user (findFirst with user_id check)
- Throw NotFoundException if not found or not owned
- If categoryId provided, verify category exists AND (is_default OR belongs to user)
- Throw BadRequestException if category invalid
- Update transaction with prisma.transactions.update
- Return updated transaction with category included (same mapping as findAll)

Update `findAll` to include category in the response:
- Add `include: { category: true }` to Prisma query
- Map category to camelCase in response

**Controller (transactions.controller.ts):**

Add PATCH endpoint:
```typescript
@Patch(':id')
@UseGuards(JwtAuthGuard)
@ApiBearerAuth()
@ApiOperation({ summary: 'Update transaction category or notes' })
@ApiParam({ name: 'id', description: 'Transaction UUID' })
@ApiBody({ type: UpdateTransactionDto })
@ApiResponse({ status: 200, type: TransactionDto })
@ApiResponse({ status: 404, description: 'Transaction not found' })
async update(
  @CurrentUser() user: AuthUser,
  @Param('id') id: string,
  @Body() updateDto: UpdateTransactionDto,
): Promise<TransactionDto>
```
  </action>
  <verify>
`cd apps/api && npm run build` succeeds.
`cd apps/api && npm run lint` passes.
Swagger shows PATCH /transactions/:id endpoint.
  </verify>
  <done>PATCH endpoint allows updating categoryId and notes on transactions. Transaction responses include category object when assigned.</done>
</task>

</tasks>

<verification>
1. `cd packages/database && npx prisma db push` - schema applied
2. `cd apps/api && npm run build && npm run lint` - builds and lints clean
3. `turbo dev --filter=api` - API starts without errors
4. Visit http://localhost:3000/api - Swagger shows PATCH /transactions/:id
5. Test with curl:
   - GET /transactions returns transactions with category field (null initially)
   - PATCH /transactions/:id with categoryId sets category
   - PATCH /transactions/:id with notes updates notes
   - GET /transactions shows updated category in response
</verification>

<success_criteria>
- transactions table has category_id column with foreign key to categories
- PATCH /transactions/:id accepts {categoryId, notes} body
- Transaction can have category assigned/changed
- Transaction can have notes updated
- Transaction response includes full category object when assigned
- Proper authorization (only update own transactions, only use valid categories)
</success_criteria>

<output>
After completion, create `.planning/phases/03-categorization/03-02-SUMMARY.md`
</output>
