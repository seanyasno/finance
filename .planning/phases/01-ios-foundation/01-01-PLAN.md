---
phase: 01-ios-foundation
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - apps/finance/finance/Services/APIService.swift
  - apps/finance/finance/Services/AuthManager.swift
  - apps/finance/finance/Services/KeychainService.swift
  - apps/finance/finance/Models/User.swift
  - apps/finance/finance/Models/AuthModels.swift
autonomous: true

must_haves:
  truths:
    - "HTTP client can make authenticated requests to NestJS API"
    - "Auth token persists securely in iOS Keychain across app restarts"
    - "Auth state is observable and updates when user logs in/out"
  artifacts:
    - path: "apps/finance/finance/Services/APIService.swift"
      provides: "HTTP client with configurable base URL and auth headers"
      exports: ["APIService", "APIError"]
    - path: "apps/finance/finance/Services/AuthManager.swift"
      provides: "Observable auth state and login/register/logout methods"
      exports: ["AuthManager", "AuthState"]
    - path: "apps/finance/finance/Services/KeychainService.swift"
      provides: "Secure storage for auth token"
      exports: ["KeychainService"]
    - path: "apps/finance/finance/Models/User.swift"
      provides: "User model matching API response"
      exports: ["User"]
    - path: "apps/finance/finance/Models/AuthModels.swift"
      provides: "Request/response DTOs for auth endpoints"
      exports: ["LoginRequest", "RegisterRequest", "AuthResponse"]
  key_links:
    - from: "apps/finance/finance/Services/AuthManager.swift"
      to: "apps/finance/finance/Services/APIService.swift"
      via: "APIService dependency for auth API calls"
      pattern: "apiService\\.(login|register|logout|getCurrentUser)"
    - from: "apps/finance/finance/Services/AuthManager.swift"
      to: "apps/finance/finance/Services/KeychainService.swift"
      via: "KeychainService for token persistence"
      pattern: "keychainService\\.(save|load|delete)"
---

<objective>
Build the networking and authentication foundation for the iOS app.

Purpose: Establish the core infrastructure that all authenticated features will depend on - HTTP client, auth state management, and secure token storage.

Output: Working APIService, AuthManager, KeychainService, and data models that enable the app to communicate with the NestJS backend and persist authentication state.
</objective>

<execution_context>
@/Users/seanyasno/.claude/get-shit-done/workflows/execute-plan.md
@/Users/seanyasno/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md

Existing API endpoints (from apps/api/src/auth/auth.controller.ts):
- POST /auth/register - body: {email, password, firstName?, lastName?} -> {user, message}
- POST /auth/login - body: {email, password} -> {user}
- POST /auth/logout -> {message}
- GET /auth/me (requires auth) -> {user}

API runs on http://localhost:3100 (from apps/api/src/main.ts)

The auth system uses JWT stored in httpOnly cookie 'auth-token'. For iOS, we need to:
1. Extract the token from the Set-Cookie header on login/register responses
2. Store it securely in Keychain
3. Send it as Authorization: Bearer header on subsequent requests
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create data models for auth</name>
  <files>
    apps/finance/finance/Models/User.swift
    apps/finance/finance/Models/AuthModels.swift
  </files>
  <action>
Create Models directory and Swift models matching the NestJS API DTOs.

User.swift:
- `User` struct conforming to `Codable` and `Identifiable`
- Properties: id (String), email (String), firstName (String?), lastName (String?), createdAt (String?)

AuthModels.swift:
- `LoginRequest` struct: email (String), password (String)
- `RegisterRequest` struct: email (String), password (String), firstName (String?), lastName (String?)
- `AuthResponse` struct: user (User?), message (String?)
- `UserResponse` struct: user (User?)

All structs should conform to Codable. Use explicit CodingKeys if property names differ from JSON keys.
  </action>
  <verify>
Build the Xcode project - no compilation errors for model files.
  </verify>
  <done>
User and auth request/response models exist and compile successfully.
  </done>
</task>

<task type="auto">
  <name>Task 2: Create KeychainService for secure token storage</name>
  <files>
    apps/finance/finance/Services/KeychainService.swift
  </files>
  <action>
Create Services directory and KeychainService using iOS Security framework.

KeychainService class:
- Private constant `service = "com.finance.app"` for keychain service identifier
- `save(token: String, forKey key: String) throws` - save string to keychain
- `load(forKey key: String) -> String?` - load string from keychain, returns nil if not found
- `delete(forKey key: String) throws` - remove item from keychain

Use `kSecClassGenericPassword` for storage class. Handle keychain errors appropriately:
- `errSecDuplicateItem` - delete existing item first, then save
- `errSecItemNotFound` - return nil from load, ignore on delete

Define `KeychainError` enum with cases: saveFailed, loadFailed, deleteFailed

Import Security framework.
  </action>
  <verify>
Build the Xcode project - KeychainService compiles without errors.
  </verify>
  <done>
KeychainService can save, load, and delete auth tokens from iOS Keychain.
  </done>
</task>

<task type="auto">
  <name>Task 3: Create APIService for HTTP networking</name>
  <files>
    apps/finance/finance/Services/APIService.swift
  </files>
  <action>
Create APIService class using URLSession for HTTP communication with the NestJS API.

APIService class:
- `baseURL` property (default: "http://localhost:3100" - use 127.0.0.1 for iOS simulator)
- `authToken` property (optional String) - set by AuthManager after login
- Private `urlSession: URLSession`

Define `APIError` enum with cases:
- invalidURL
- networkError(Error)
- invalidResponse
- httpError(statusCode: Int, message: String?)
- decodingError(Error)

Methods:
- `func request<T: Decodable>(_ endpoint: String, method: String, body: Encodable?, authenticated: Bool) async throws -> T`
  - Constructs URL from baseURL + endpoint
  - Sets Content-Type: application/json header
  - If authenticated && authToken != nil, adds Authorization: Bearer {token} header
  - Encodes body as JSON if provided
  - Uses async/await with URLSession.data(for:)
  - Checks HTTP status code (200-299 = success)
  - Decodes response body as T

Convenience methods:
- `func get<T: Decodable>(_ endpoint: String, authenticated: Bool = true) async throws -> T`
- `func post<T: Decodable, B: Encodable>(_ endpoint: String, body: B, authenticated: Bool = false) async throws -> T`

Note: iOS simulator uses localhost differently - use "http://127.0.0.1:3100" as default baseURL.
  </action>
  <verify>
Build the Xcode project - APIService compiles without errors.
  </verify>
  <done>
APIService can make GET/POST requests to the NestJS API with optional auth headers.
  </done>
</task>

<task type="auto">
  <name>Task 4: Create AuthManager for auth state management</name>
  <files>
    apps/finance/finance/Services/AuthManager.swift
  </files>
  <action>
Create AuthManager as an ObservableObject that manages authentication state.

AuthManager class (ObservableObject):
- `@Published var currentUser: User?` - nil when not authenticated
- `@Published var isLoading: Bool = false`
- `@Published var error: String?`
- Private `let apiService: APIService`
- Private `let keychainService = KeychainService()`
- Private constant `tokenKey = "auth_token"`

Computed property:
- `var isAuthenticated: Bool { currentUser != nil }`

Methods:
- `init()` - create APIService, call loadStoredToken()
- `func loadStoredToken()` - load token from keychain, set on apiService, try to fetch current user
- `func login(email: String, password: String) async throws`
  - Set isLoading = true, clear error
  - Call POST /auth/login with LoginRequest
  - On success: save received token to keychain, set on apiService, set currentUser
  - On failure: set error message
  - Set isLoading = false
- `func register(email: String, password: String, firstName: String?, lastName: String?) async throws`
  - Similar to login but calls POST /auth/register with RegisterRequest
- `func logout() async`
  - Call POST /auth/logout (best effort, don't throw on error)
  - Clear token from keychain
  - Clear authToken from apiService
  - Set currentUser = nil
- `func checkAuthStatus() async`
  - Try GET /auth/me
  - On success: set currentUser
  - On failure: call logout() to clear invalid state

IMPORTANT: The NestJS API returns JWT in cookies, but for iOS we need to handle this differently.
Look for the 'auth-token' value in the response. The API may need to be extended to also return
the token in the response body for mobile clients. For now, implement with the expectation that
the token will be in the AuthResponse - if it's not available, the API will need a small update
to include `accessToken` in the response body.

Add `accessToken: String?` to AuthResponse to handle this.
  </action>
  <verify>
Build the Xcode project - AuthManager compiles and can be instantiated.
  </verify>
  <done>
AuthManager tracks auth state, persists tokens in Keychain, and provides login/register/logout methods.
  </done>
</task>

</tasks>

<verification>
1. All Swift files compile without errors: `xcodebuild -project apps/finance/finance.xcodeproj -scheme finance build`
2. Models match API response structure from apps/api/src/auth/dto/auth-response.dto.ts
3. KeychainService uses Security framework correctly
4. APIService handles HTTP methods and auth headers
5. AuthManager is @Observable and publishes state changes
</verification>

<success_criteria>
- [ ] User model matches API user response structure
- [ ] Auth request/response models exist for login and register
- [ ] KeychainService can save/load/delete tokens securely
- [ ] APIService can make authenticated HTTP requests to localhost:3100
- [ ] AuthManager observes auth state and persists token across app restarts
- [ ] All files compile without errors in Xcode
</success_criteria>

<output>
After completion, create `.planning/phases/01-ios-foundation/01-01-SUMMARY.md`
</output>
